# golang

[TOC]



## 一、开发工具Sublime Text3

GoSublime 快捷键：

cmd ..  快捷键提示

cmd .h 现实对应的帮助信息

cmd .g 跳转到定义的地方

## 二、Go基础知识

基础知识见：http://www.mikespook.com/learning-go/

## 三、函数function

### 3.1 简介

- Go函数不支持嵌套、重载和默认参数
- 但是支持下边的特性：
  - 无需声明原型、不定长度变参、命名返回值参数、匿名函数、闭包
- 定义函数使用关键字 func ,且大括号不能另起一行
- 函数可以作为一种类型使用



### 3.2 defer

- 执行方式类似于其他语言中的析构函数，在函数体执行结速后，按照调用顺序的相反顺序逐个执行
- 即使函数发生严重错误也会执行
- 支持匿名函数的调用
- 常用于资源清理、文件关闭、解锁以及记录事件等操作
- 通过与匿名函数配合可在return之后修改函数计算结果
- 如果函数体內某个变量作为defer时匿名函数的参数，则在定义defer时即已获得了拷贝，否则泽施应用某个变量的地址
- Go没有异常机制，但有panic/ercover模式来处理错误
- Panic可以在任何地方引发，但recover只有defer调用的函数中有效

## 四、结构struct

### 4.1 简介

- Go中的struct与C中的struct非常相似，并且Go没有Class，所以struct就承担了Go中面向对象编程的功能
- 使用type <Name> struct{} 定义结构，名称遵循可见性规则
- 支持指向自身的指针类型成员
- 支持匿名结构，可用作成员变量
- 匿名结构也可以用于map的值
- 可以使用字面值对结构进行初始化
- 允许直接通过指正读写结构成员
- 相同类型的成员可以直接执行直接拷贝赋值
- 支持== 与!= 比较运算符， 但不支持 > 或 <
- 支持匿名字段，本质上是定义了以某个类型名为名称的字段
- 嵌入结构作为匿名字段看起来像继承，但不是继承
- 可以使用匿名字段指针

## 五、方法method

### 5.1 简介

- Go中虽然没有class，但是依旧有method
- 通过显示说明receiver来实现与某个类型的组合
- 只能为同一个包中的类型定义方法
- Receiver可以是类型的值或指针
- 不存在方法重载
- 可以使用值或指针来调用方法，编译器会自动完成转换
- 从某种意义上来说，方式是函数的法糖，因为receiver起始就是方法所接受的第1个参数
- 如果外部结构和嵌入结构存在同名方法，则优先调用外部结构的方法
- 类型别名不会拥有底层类型所附带的方法
- 方法可以调用结构中的非公开字段

## 六、接口interface

### 6.1 简介

- 接口是一个或多个方法签名的集合
- golang不需要显示的声明你实现了那个接口，只要某个类型拥有该接口的所有方法签名，即实现了改接口，无需现实实现了那个接口，这个称为Structural Typing，所有的接口实现了空接口
- 接口只有方法声明，没有实现，**没有数据字段**
- 接口可以匿名嵌入其他接口，或嵌入到结构中
- 将对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，即无法修改复制品的状态，也无法获取指针。
- 只有当接口存储的类型和对象都为nil时，接口才等于nil
- 接口调用不会做receiver的自动转换，结构会
- 接口同样支持匿名字段方法
- 接口也可以实现类似于OOP中的多态，但是没有继承的概念
- 空接口可以作为任何类型数据的容器
- 接口转换，只能用拥有超集的接口转化为它子集的接口




## 七、反射reflection

### 7.1 简介

- 反射可以大大提高程序的灵活星，使得interface{}有更大的发挥余地
- 发射使用TypeOf和ValueOf函数从接口中获取目标对象信息
- 反射会将匿名字段作为独立字段
- 想要利用反射修改对象状态，前提是interface.data是setable,即pointer-interface
- 通过反射可以动态调用方法



## 八、并发concurrency

### 8.1 简介

很多人都是冲着Go大肆宣扬的高并发而忍不住跃跃欲试，但其实从源码的解析来看，goruntine只是由官方实现的超级 "线程池" 而已。不过话说回来，每个实例4-5KB栈内存占用和由于实现机制而大幅减少的创建和销毁开销，是制造Go号称的高并发的根本原因。另外，goroutine的简单易用，也在语言层面上给予了开发者巨大的遍历。

并发主要是由切换时间片来实现"同时"运行，在并行则是直接利用多核实现多线程的运行，但Go可以设置使用核数，以便发挥多喝计算机的能力。

Goroutine 奉行通过通信来共享内存，而不是共享内存来通信。



### 8.2 channel

- Channel是goroutine沟通的桥梁，大都是阻塞同步的
- 通过make创建，close关闭
- Channel是引用类型
- 可以使用for range来迭代不断操作channel
- 可以设置单向或双向通道，直接make都是双向通道
- 可以设置缓存大小，有缓存时，在未被填满前不会发生阻塞



### 8.3 select

- 可处理一个或多个channel的发送与接收
- 同时有多个可用的channel时安随机顺序处理
- 可用空的select来阻塞main函数
- 可以设置超时